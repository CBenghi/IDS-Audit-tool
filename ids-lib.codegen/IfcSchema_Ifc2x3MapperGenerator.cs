using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using Xbim.Common.Metadata;
using Xbim.Ifc4.Kernel;
using Xbim.IO.Xml.BsConf;

namespace IdsLib.codegen;

internal class IfcSchema_Ifc2x3MapperGenerator
{
	private static IEnumerable<string[]> GetDocumentationMaps()
	{
		int get = 3;
		var markDown = File.ReadAllLines(@"buildingSMART\ifc2x3-occurrence-type-mapping-table.md");
		foreach (var line in markDown)
		{
			var modline = line.Trim(' ');
			var lineCells = modline.Split('|');
			if (lineCells.Length != get + 2)
				continue;
			var firstCell = lineCells[1].Trim();
			if (string.IsNullOrEmpty(firstCell))
				continue;
			if (!firstCell.StartsWith("Ifc"))
				continue;
			var fields = lineCells.Skip(1).Take(get).Select(x => x.Trim()).ToArray();
			yield return fields;
		}
	}

	internal static string? Execute(out List<Ifc2x3EntityMappingInformation> maps)
	{
		// start from documented maps... 
		var cells = GetDocumentationMaps();
		var conversionInfos = cells.SelectMany(x => Ifc2x3EntityMappingInformation.FromCells(x));
		maps = conversionInfos.ToList();
			
		var sbConversionInfos = new StringBuilder();
		foreach (var c in conversionInfos)
			sbConversionInfos.AppendLine($"\t\t{c},");

		var source = stub;
		source = source.Replace($"<PlaceHolderConversionInfos>\r\n", sbConversionInfos.ToString());
		source = source.Replace($"<PlaceHolderVersion>", VersionHelper.GetFileVersion(typeof(ExpressMetaData)));
		return source;
	}

	internal static void CheckExist(List<Ifc2x3EntityMappingInformation> maps)
	{
		var factory = SchemaHelper.GetFactory("IFC2X3");
		var metaD = ExpressMetaData.GetMetadata(factory);
		if (metaD is null)
			throw new Exception("Could not get metadata for IFC2X3 schema.");

		foreach (var map in maps)
		{
			var sourceFound = metaD.TryGetExpressType(map.IdsEntity.ToUpperInvariant(), out var sourceEnt);
			var mappedEntFound = metaD.TryGetExpressType(map.IfcEntity.ToUpperInvariant(), out var mapEnt);
			var mappedTypeFound = metaD.TryGetExpressType(map.IfcEntityType.ToUpperInvariant(), out var mapType);
			if (sourceFound || !mappedEntFound || !mappedTypeFound)
			{
				Debug.WriteLine($"Invalid mapping: {sourceFound} {mappedEntFound} {mappedTypeFound} ... {map.IdsEntity} -> {map.IfcEntity}/{map.IfcEntityType}");
				throw new Exception("Invalid mapping found, see debug output for details.");
			}
		}
	}

	private const string stub = """"
		// <auto-generated/>
		// This code was automatically generated with information from Xbim.Essentials <PlaceHolderVersion>.
		// Any changes made to this file will be lost.

		using System;
		using System.Collections.Generic;

		namespace IdsLib.IfcSchema;

		/// <summary>
		/// Mapping information for an entity mapping from an IFC4 class to the equivalent IFC2x3 class and type, 
		/// as documented by buildingSMART in the ifc2x3-occurrence-type-mapping-table.md file.
		/// 
		/// For example, the definition of an IDS applicability facet with entity `IfcFilter`, 
		/// should result in the identification of all `IfcFlowTreatmentDevice` in the model 
		/// that are associated with a type `IfcFilterType`.
		/// </summary>
		public class Ifc2x3EntityMappingInformation
		{
			/// <summary>
			/// Entity name as identified by the IDS file (not a valid IFC2x3 entity name)
			/// </summary>
			public string IdsEntity { get; }
			/// <summary>
			/// Entity name of the IFC occurrences in the IFC2x3 schema (valid IFC2x3 entity name).
			/// Filters need to include the type, so that only occurrences belonging to type <see cref="IfcEntityType"/> are included in the mapping.
			/// </summary>
			public string IfcEntity { get; }
			/// <summary>
			/// Type name of the IFC occurrences in the IFC2x3 schema (valid IFC2x3 entity type name).
			/// </summary>
			public string IfcEntityType { get; }

			/// <summary>
			/// Initializing constructor for the mapping information, with trimming of the input strings
			/// </summary>
			public Ifc2x3EntityMappingInformation(string sourceEntity, string mappedEntity, string mappedType)
			{
				IdsEntity = sourceEntity.Trim();
				IfcEntity = mappedEntity.Trim();
				IfcEntityType = mappedType.Trim();
			}
		}
		
		public partial class SchemaInfo
		{
			private static readonly Ifc2x3EntityMappingInformation[] _ifc2x3SchemaMaps = [
		<PlaceHolderConversionInfos>
				];

			/// <summary>
			/// Provides a list of IDS entity names that need to be remapped when dealing with IFC2x3 schema.
			/// See <see cref="Ifc2x3EntityMappingInformation"/> for more information on the mapping and its intended use.
			/// </summary>
			public static IEnumerable<Ifc2x3EntityMappingInformation> Ifc2x3SpecialEntityMaps => _ifc2x3SchemaMaps;
		}
		"""";

	/// <summary>
	/// Mapping information for an entity mapping from an IFC4 class to the equivalent IFC2x3 class and type, 
	/// as documented by buildingSMART in the ifc2x3-occurrence-type-mapping-table.md file.
	/// 
	/// For example, the definition of an IDS applicability facet with entity `IfcFilter`, 
	/// should result in the identification of all `IfcFlowTreatmentDevice` in the model 
	/// that are associated with a type `IfcFilterType`.
	/// </summary>
	public class Ifc2x3EntityMappingInformation
	{
		/// <summary>
		/// Entity name as identified by the IDS file (not a valid IFC2x3 entity name)
		/// </summary>
		public string IdsEntity { get; }
		/// <summary>
		/// Entity name of the IFC occurrences in the IFC2x3 schema (valid IFC2x3 entity name).
		/// Filters need to include the type, so that only occurrences belonging to type <see cref="IfcEntityType"/> are included in the mapping.
		/// </summary>
		public string IfcEntity { get; }
		/// <summary>
		/// Type name of the IFC occurrences in the IFC2x3 schema (valid IFC2x3 entity type name).
		/// </summary>
		public string IfcEntityType { get; }

		/// <summary>
		/// Initializing constructor for the mapping information, with trimming of the input strings
		/// </summary>
		public Ifc2x3EntityMappingInformation(string sourceEntity, string mappedEntity, string mappedType)
		{
			IdsEntity = sourceEntity.Trim();
			IfcEntity = mappedEntity.Trim();
			IfcEntityType = mappedType.Trim();
		}

		internal static IEnumerable<Ifc2x3EntityMappingInformation> FromCells(string[] sourceCells)
		{
			yield return new Ifc2x3EntityMappingInformation(
				sourceCells[0],
				sourceCells[1],
				sourceCells[2]
				);
		}

		public override string ToString()
		{
			return $"""new {nameof(Ifc2x3EntityMappingInformation)}("{IdsEntity}", "{IfcEntity}", "{IfcEntityType}")""";
		}
	}
}
