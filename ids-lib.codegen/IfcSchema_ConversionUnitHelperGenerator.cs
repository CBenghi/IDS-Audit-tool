using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using Xbim.Common.Metadata;
using Xbim.Ifc4.Kernel;

namespace IdsLib.codegen;

internal class IfcSchema_ConversionUnitHelperGenerator
{
	private static IEnumerable<string[]> GetDocumentationConversionMeasures()
	{
		int get = 2;
		var markDown = File.ReadAllLines(@"buildingSMART\IfcConversionBasedUnit.md");
		foreach (var line in markDown)
		{
			var modline = line.Trim(' ');
			var lineCells = modline.Split('|');
			if (lineCells.Length != get + 2)
				continue;
			var firstCell = lineCells[1].Trim();
			if (string.IsNullOrEmpty(firstCell))
				continue;
			var fields = lineCells.Skip(1).Take(get).Select(x => x.Trim()).ToArray();
			yield return fields;
		}
	}

	static ConversionInfo[] extraConversions = [
		new ConversionInfo("mm", "length", "0.001", "m", ""),
		new ConversionInfo("g", "mass", "0.001", "kg", ""),
		new ConversionInfo("square meter", "area", "1", "m2", ""),
		new ConversionInfo("cubic meter", "volume", "1", "m3", ""),
		new ConversionInfo("Kg", "mass", "1", "kg", ""),
		new ConversionInfo("°F", "thermodynamictemperature", "1.8", "°K", "Fahrenheit", "-459.67"),
		];

	internal static string? Execute()
	{
		// start from documented... 
		var cells = GetDocumentationConversionMeasures();
		var conversionInfos = cells.SelectMany(x => ConversionInfo.FromCells(x))
			.Concat(extraConversions);
		var sbConversionInfos = new StringBuilder();
		foreach (var c in conversionInfos)
			sbConversionInfos.AppendLine($"\t\t{c},");

		var source = stub;
		source = source.Replace($"<PlaceHolderConversionInfos>\r\n", sbConversionInfos.ToString());
		source = source.Replace($"<PlaceHolderVersion>", VersionHelper.GetFileVersion(typeof(ExpressMetaData)));

		return source;
	}

	private const string stub = """
		// <auto-generated/>
		// This code was automatically generated with information from Xbim.Essentials <PlaceHolderVersion>.
		// Any changes made to this file will be lost.

		using System;
		using System.Collections.Generic;

		namespace IdsLib.IfcSchema;
		
		public partial class SchemaInfo
		{
			private static readonly IfcConversionUnitInformation[] _conversionUnits = [
		<PlaceHolderConversionInfos>
				];

			/// <summary>
			/// Some standard unit conversions found in IFC files, including those defined in the buildingSMART documentation
			/// </summary>
			public static IEnumerable<IfcConversionUnitInformation> StandardConversionUnits => _conversionUnits;
		}
		""";

	private class ConversionInfo
	{
		private string unitName;
		private string ifcTypeName;
		private string conversionRatio;
		private string otherunit;
		private string[] alsoKnownAs;
		private string offset = "null";

		public override string ToString()
		{
			if (!alsoKnownAs.Any() && offset == "null")
				return $"""new IfcConversionUnitInformation("{unitName}", "{ifcTypeName}", {conversionRatio}, "{otherunit}")""";		
			IEnumerable<string> allNames = [unitName];
			allNames = allNames.Concat(alsoKnownAs);
			var quotationNames = string.Join(", ", allNames.Select(x=>$"\"{x}\""));
			return $"""new IfcConversionUnitInformation([{quotationNames}], "{ifcTypeName}", {conversionRatio}, "{otherunit}", {offset})""";
		}

		public ConversionInfo(string name, string type, string conversion, string unit, string commaSeparatedAka, string offset)
			: this(name, type, conversion, unit, commaSeparatedAka)
		{
			this.offset = offset;
		}

		public ConversionInfo(string name, string type, string conversion, string unit, string commaSeparatedAka)
		{
			unitName = name.Trim();

			// known type misspellings
			if (type.ToUpperInvariant() == "ANGLE")
				type = "PLANEANGLE";

			ifcTypeName = $"IFC{type.Trim().ToUpper()}MEASURE";
			conversion = conversion.Replace(" ", "");
			if (conversion == "π/180")
				// R for roundtrip, produces the maximum precision representable by a double
				conversionRatio = (Math.PI / 180.0).ToString("R", CultureInfo.InvariantCulture); 
			else
				conversionRatio = conversion;
			otherunit = unit.Trim();
			// known unit misspellings
			otherunit = otherunit.Replace("meters", "meter");
			//if (otherunit == "Kg")
			//	otherunit = "kg";

			alsoKnownAs =
				!string.IsNullOrWhiteSpace(commaSeparatedAka)
				? commaSeparatedAka.Split(",").Select(x => x.Trim()).ToArray()
				: [];
		}

		static Regex rName = new Regex(@"^'(?<name>.+)'$");
		static Regex rDesc = new Regex(@"^(?<type>.+) measure equal to (?<conversion>[\d\.π/ ]+) (?<otherunit>[^,\(]*)(,( also known as )?(?<aka>.*))?(\(.*)?");

		internal static IEnumerable<ConversionInfo> FromCells(string[] sourceCells)
		{
			string unitName = sourceCells[0];
			string unitDescription = sourceCells[1];

			// valid if unitName is in single quotes
			var m1 = rName.Match(unitName);
			if (!m1.Success)
				yield break;
			var m2 = rDesc.Match(unitDescription);
			if (!m2.Success)
			{
				Program.Message($"Failed to parse `{unitDescription}`, the rDesc regex needs to be revised.", ConsoleColor.Yellow);
				yield break;
			}
			yield return new ConversionInfo(
				m1.Groups["name"].Value,
				m2.Groups["type"].Value,
				m2.Groups["conversion"].Value,
				m2.Groups["otherunit"].Value,
				m2.Groups["aka"].Value
				);
		}
	}
}
