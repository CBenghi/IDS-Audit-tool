using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace IdsLib.codegen
{
	internal class XmlSchema_XsTypesGenerator
	{
		internal static string Execute(Dictionary<string, typeMetadata> dataTypeDictionary)
		{
			var sbXmlTypes = new StringBuilder();
			var xmlTypes = dataTypeDictionary.Values.Select(x => x.XmlBackingType).Where(str => !string.IsNullOrWhiteSpace(str)).Distinct();
			foreach (var dataType in xmlTypes.OrderBy(x => x))
			{
				var t = XmlSchema_XsTypesGenerator.GetRegexString(dataType);
				if (string.IsNullOrWhiteSpace(t))
					continue;
				var name = dataType.Replace("xs:", "");
				name = name[..1].ToUpper() + name[1..];	
				sbXmlTypes.AppendLine($"\t\tprivate readonly static Regex regex{name} = new(@\"{t}\", RegexOptions.Compiled);");
			}

			var source = stub;
			source = source.Replace($"<PlaceHolderXmlRegexes>", sbXmlTypes.ToString().TrimEnd('\r', '\n'));
			return source;
		}

		internal static string GetRegexString(string dataType)
		{
			return dataType switch
			{
				"xs:boolean" => @"^(true|false|0|1)$",
				"xs:date" => @"^\d{4}-\d{2}-\d{2}(Z|([+-]\d{2}:\d{2}))?$",
				"xs:dateTime" => @"^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([+-]\d{2}:\d{2}))?$",
				"xs:double" => @"^([-+]?[0-9]*\.?[0-9]*([eE][-+]?[0-9]+)?|NaN|\+INF|-INF)$",
				"xs:duration" => @"^[-+]?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+S)?)?$",
				"xs:integer" => @"^[+-]?(\d+)$",
				"xs:string" => @"^.*$",
				"xs:time" => @"^\d{2}:\d{2}:\d{2}(\.\d+)?(Z|([+-]\d{2}:\d{2}))?$",
				_ => ""
			};
		}

		private const string stub = @"// <auto-generated/>
// This code was automatically generated.
// Any changes made to this file will be lost.

using System.Text.RegularExpressions;

namespace IdsLib.IdsSchema.XsNodes
{
	public static partial class XsTypes
	{
<PlaceHolderXmlRegexes>
	}
}
";
	}
}
