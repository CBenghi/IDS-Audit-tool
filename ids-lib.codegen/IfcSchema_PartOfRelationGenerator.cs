using System.Text;
using Xbim.Common.Metadata;

namespace IdsLib.codegen;

public class IfcSchema_PartOfRelationGenerator
{
    private class GenOneToManyRelationInfo
    {
        public void AddSchema(string schema, string oneType, string manyType)
        {
            Schemas.Add(schema);
            if (manyType != ManyType)
                throw new ArgumentException($"Inconsistent type across schemas on enumerable side of the {RelationName} relation ({manyType} vs. {ManyType}), we need to rethink auditing logic.");
            if (oneType != OneType)
                throw new ArgumentException($"Inconsistent type across schemas on one-side of the {RelationName} relation ({oneType} vs. {OneType}), we need to rethink auditing logic.");
        }

        public GenOneToManyRelationInfo(string relationName, string schema, string oneType, string enumerableType)
        {
            RelationName = relationName;
            OneType = oneType;
            ManyType = enumerableType;
            Schemas = new List<string>() { schema };
        }

        internal List<string> Schemas { get; set; } 
        internal string ManyType { get; set; } 
        internal string OneType { get; set; } 
        internal string RelationName { get; set; } 
    }

    internal static string Execute()
    {
        var relationNames = GetRelationNames();

        var measureInfos = new Dictionary<string, GenOneToManyRelationInfo>();
        foreach (var schema in Program.schemas)
        {
            System.Reflection.Module module = SchemaHelper.GetModule(schema);
            var metaD = ExpressMetaData.GetMetadata(module);
            foreach (var daRelation in relationNames)
            {
                try
                {
                    var t = metaD.ExpressType(daRelation.ToUpperInvariant());
                    if (t is null)
                        continue;
                    
                    var propOnManySide = t.Properties.Single(x => x.Value.EnumerableType is not null).Value;
                    var manyType = propOnManySide.EnumerableType;
                    var manyExpressType = metaD.ExpressType(manyType.Name.ToUpperInvariant());

                    var propOnOneSide = t.Properties.Single(x => x.Value.EnumerableType is null && x.Value.Name.StartsWith("Relating")).Value;
                    var oneType = propOnOneSide.PropertyInfo.PropertyType;
                    var oneExpressType = metaD.ExpressType(oneType.Name.ToUpperInvariant());

                    if (measureInfos.TryGetValue(daRelation, out var lst))
                        lst.AddSchema(schema, oneExpressType.Name, manyType.Name);
                    else
                        measureInfos.Add(daRelation, new GenOneToManyRelationInfo(daRelation, schema, oneExpressType.Name, manyType.Name));                    
                }
                catch 
                {
                    continue;
                }                
            }
        }
        var source = stub;
        var sbMeasures = new StringBuilder();
        foreach (var clNm in measureInfos.Keys.OrderBy(x => x))
        {
            var relInfo = measureInfos[clNm];
            sbMeasures.AppendLine($"""               yield return new IfcOneToManyRelationInformation("{clNm}", {CodeHelpers.NewStringArray(relInfo.Schemas)}, "{relInfo.OneType}", "{relInfo.ManyType}");""");
        }
        source = source.Replace($"<PlaceHolderRelations>\r\n", sbMeasures.ToString());
        source = source.Replace($"<PlaceHolderVersion>", VersionHelper.GetFileVersion(typeof(ExpressMetaData)));
        return source;
    }

    private static IEnumerable<string> GetRelationNames()
    {
        yield return "IFCRELAGGREGATES";
        yield return "IFCRELASSIGNSTOGROUP";
        yield return "IFCRELCONTAINEDINSPATIALSTRUCTURE";
        yield return "IFCRELNESTS";
        yield return "IFCRELVOIDSELEMENT";
        yield return "IFCRELFILLSELEMENT";
    }

    private const string stub = @"// <auto-generated/>
// This code was automatically generated with information from Xbim.Essentials <PlaceHolderVersion>.
// Any changes made to this file will be lost.

using System;
using System.Collections.Generic;

namespace IdsLib.IfcSchema
{
    public partial class SchemaInfo
    {
        /// <summary>
        /// The names of classes across all schemas.
        /// </summary>
        public static IEnumerable<IfcOneToManyRelationInformation> AllPartOfRelations
        {
            get
            {
<PlaceHolderRelations>
            }
        }
    }
}

";

}
